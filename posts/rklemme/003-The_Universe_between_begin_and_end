=title The Universe between <code>begin</code> and <code>end</end>
=description The article was inspired by <a href="posts/rklemme/002_Writing_Block_Methods.html">last article's</a> ccomments.  Much has been said in the comments already and today I'll mostly try to combine and organize it to give an overview from <tt>begin</tt> to <tt>end</tt>.
=entry
This time we'll explore the space between @begin@ and @end@.  Today's article won't be as much about individual best practices but rather I will try to explore various aspects of @begin ... end@ blocks so you can decide how to make best use of this tool.  In fact, there are so many aspects that this construct sometimes reminds me of a swiss army knife - not so much because you can do everything with it but rather because it has so many features that you can use.  When it comes to control structuring elements @begin ... end@ is probably the most complex thing found in Ruby.

One final introductory remark: although I am pretty sure that Ruby hasn't changed between 1.8 and 1.9 with regard to @begin ... end@ I did my tests with 1.9.1 only.  So if you find something to be wrong, please comment!

h3. Starting the Investigation

For easier reference here's a block which contains all the options:

<pre name="code" class="ruby">
begin
  # do our work
rescue
  # standard oops!
rescue SomeException => e
  # oops!
rescue Exception => e
  # deal with other errors
else
  # good, no exception surfaced!
ensure
  # good or bad, this needs to be done
end
</pre>

Note that you can replace @begin@ with @def...@ to define a method with "integrated" exception handling.  That way you can avoid one level of nesting.

There are various interesting aspects to each section:

* control flow (most particularly, how is the section left?),
* result (if any)
* documentation (what does it tell me that code is in a particular section?).

We'll keep these in the back of our heads when exploring section after section.

h3. main section

This section begins right after the @begin</begin> - no surprises so far.  This is where you place the code that should do the work you want to get done.  If evaluation reaches the end of this section normally the result of the last expression evaluated is also the result of this section.  In the absence of @rescue@ or @else@ that value is propagated to the surrounding context.

If we look at control flow things start to get a bit more involved.  First, you should note that there are these additional ways this section (actually _any_ section of code) can be terminated:

* @return@ is executed,
* @break@ is executed in a @do@ block invoked,
* an exception is triggered via @raise@,
* @throw@ is invoked.

I'm sure you haven't thought of all of them.  (Did *I* miss another one?)  All these have one thing in common: the end of the section is not reached normally and the code produces a different result.

h3. @rescue@

This can have an optional @ExceptionType => variable@ in which case exceptions of this class and subclasses (if there are no preceeding rescue clauses with them) are caught.  If that optional part is missing only @StandardError@ and subclasses are caught.

In case a rescue clause is executed the result of the whole block is that of the code in the rescue clause.  In other words: when catching exceptions the exception code replaces the block's result.  Unless, that is, you invoke @raise@ or @retry@.

h3. @else@

This section does make sense only if there is a @rescue@ as well.  (You'll get a warning if you use it without it.)  If the main section completes regularly and an @else@ section is present it is executed.

Now, some of the "discussion":http://blog.rubybestpractices.com/posts/rklemme/002_Writing_Block_Methods.html#dsq-cite-8500023 revolved around the utility of this section and whether code placed here is equivalent to code placed in other places.  While at first sight it may seem that you can just place it at the end of the main section a closer look reveals some subtlties, some of which have been mentioned already:

* If the code raises an exception, it might be rescued when placed in the main section but it won't be rescued when placed in @else@ section.
* Placing the code after @end@ generally has the same effect as putting it in an @else@ section but: when using a shortcut version of @begin ... end@ in a method definition there is no place "after end" - at least nothing that is executed as part of the method invocation:

<pre name="code" class="ruby">
def do_the_work
  some_code_which_may_throw
rescue ArgumentError
  $stderr.puts "Ooops! Passed the wrong argument."
else
  puts "Job done."
end
</pre>

h3. @ensure@

